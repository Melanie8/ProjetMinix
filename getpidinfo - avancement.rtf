{\rtf1\ansi\ansicpg1252\cocoartf1265
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red63\green105\blue30;\red221\green32\blue103;\red41\green0\blue130;
\red98\green147\blue254;\red168\green24\blue75;\red59\green0\blue164;}
{\info
{\author Lena Peschke}}\paperw11904\paperh16836\margl1440\margr1440\vieww12640\viewh12520\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc

\f0\fs24 \cf0 Impl\'e9mentation de l\'92appel syst\'e8me getpidinfo\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
ssh identifiant@studssh.info.ucl.ac.be (peschke)\
[mot de passe] (beihau6Quo8v)\
ssh volcan01\
[mot de passe]\
[se placer dans le r\'e9pertoire de minix]\
\
FICHIER : \cf2 ~/src/include/minix/callnr.h\cf0 \
Rep\'e9rer un num\'e9ro non utilis\'e9 (32)\
Ajouter \cf3 #define GETPIDINFO	  32\cf0 \
\
\
FICHIER : \cf2 ~/src/servers/pm/table.c\cf0 \
Ajouter \cf3 do_getpidinfo,	/* 32 = getpidinfo */\cf0 \
\
\
FICHIER : \cf2 ~/src/servers/pm/proto.h\cf0 \
Ajouter \cf3 _PROTOTYPE( int do_getpidinfo,(void)			);\cf0 \
dans la section /* misc.c */\
\
\
FICHIER : \cf2 ~/src/server/pm/misc.c\cf0 \
Ajouter le code ci-dessous; attention \'e0 ne pas utiliser de commentaire //, donc seulement  des /* text */. On peut s\'92inspirer de la fonction do_getepinfo dans le m\'eame fichier, qui ressemble sur plusieurs points (elle utilise aussi mp, elle fonctionne aussi par messages et met \'e0 jour errno), et de ce qui se trouve dans getset.c.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 \CocoaLigature0 /*===========================================================================*\
 *				do_getpidinfo				 		                                                           *\
 *===========================================================================*/\
PUBLIC int do_getpidinfo()\
\{\
  /* mproc and mp are extern variables declared in mproc.h and glo.h */\
\
  /* message */\
  if (mp->mp_flags & IN_USE) \{\
	mp->mp_reply.reply_res2 = mproc[who_p].mp_pid;\
	mp->mp_reply.reply_res3 = mproc[mp->mp_parent].mp_pid;\
  	return(OK);\
  \}\
\
  /* inactive process */\
  return(ESRCH);\
\}\CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
\'c0 cette \'e9tape, il faut comprendre plusieurs choses. Le r\'e9pertoire pm/ contient full fichiers .h. Voici un aper\'e7u:\
\
glo.h : contient toutes les variables globales. C\'92est ici qu\'92est d\'e9clar\'e9 struct mproc *mp qui est la *table* du processus courant contenant toutes ses infos. Cette structure est d\'e9finie ailleurs, mais retenons que comme elle est d\'e9clar\'e9e externe ici, on ne doit plus la d\'e9clarer et la chercher pour notre appel.\
\
mproc.h : c\'92est ici que struct mproc *mp est d\'e9finie et o\'f9 mproc[] est d\'e9lcar\'e9. Vaut la peine d\'92\'eatre lu. On se rend compte que c\'92est une table de structure qui contient tous les processus. mp (voir ci-dessus) pointe sur l\'92entr\'e9e du processus courant. A l\'92int\'e9rieur de la structure, on retrouve les champs pid_t mp_pid et int mp_parent qui donne respectivement le pid du processus et l\'92index dans mproc[NR_PROCS] de son parent. Autre chose d\'92important : message mp_reply. Pour comprendre ce champ, il faut savoir que tout appel syst\'e8me est appel\'e9 comme ceci : _syscall(PM_PROC_NR, PROC_NAME, &m); avec comme arguments la table qui donne les num\'e9ros au appels syst\'e8mes (je crois), le nom de l\'92appel syst\'e8me et le pointeur d\'92un message. mp_reply (le message) contient lui-m\'eame plusieurs champs.\
\
param.h : contient des d\'e9finitions des champs d\'92un message. On s\'92int\'e9resse \'e0 reply_res2 (=m2_i1) et reply_res3 (=m2_i3), dans lesquels on peut placer des int pour un retour de donn\'e9es multiples (chez nous donc pid et ppid).\
\
pm.h : master-fichier-header. Tous les fichiers .c du dossier l\'92includent.\
\
\
FICHIER : \cf2 ~/src/include/minix/type.h\cf0 \
C\'92est ici qu\'92on ajoute la d\'e9finition de la nouvelle structure.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf3 struct pid_s \{\
	pid_t me;\
	pid_t parent;\
\};\cf0 \
\
\
(dans le dossier o\'f9 se trouve minix)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf4 make run\
cd /usr/src/servers/pm/\
make\cf0 \
(ressortir)\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
A ce stade, l\'92appel syst\'e8me existe et il faut le rendre accessible aux utilisateurs de mani\'e8re plus ais\'e9e que par _syscall(\'85).\
\
\
FICHIER : \cf2 ~/src/lib/libc/other\cf0 \
Il y a plusieurs dossiers de librairie, mais celui-ci me paraissait le plus appropri\'e9 pour notre appel syst\'e8me. C\'92est ici qu\'92est utilis\'e9 getepinfo, pas en tant que tel mais pour plusieurs sous-fonctions (_getngid.c, _getnuid.c,\'85).\
Ajouter un nouveau fichier _\cf2 getpidinfo.c\cf0  :\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 \CocoaLigature0 \
#include <lib.h>\
#define getpidinfo _getpidinfo\
#include <unistd.h>\
\
PUBLIC int getpidinfo(struct pid_s *pids)\
\{  \
  message m;\
  int result;\
\
  result = _syscall(PM_PROC_NR, GETPIDINFO, &m);\
\
  if (result \cf5 >=\cf3  0) \{\
	pids->me = (pid_t) m.m2_i1;\
	pids->parent = (pid_t) m.m2_i2;\
  \}\
\
  return result;\
\} \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf6 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
FICHIER : \cf2 ~/src/lib/libc/other/Makefile.inc\cf0 \
Ajouter \cf3 _getpidinfo.c \\\cf0  dans la liste\
\
\
FICHIER : \cf2 ~/src/include/unistd.h\
\cf0 Ajouter\cf3  _PROTOTYPE( int getpidinfo, (struct pid_s *pids)		);\
\
\
\cf0 FICHIER : \cf2 ~/src/lib/libc/syscall\cf0 \
Ajouter un fichier \cf2 getpidinfo.S\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 \CocoaLigature0 #include <machine/asm.h>\
\
IMPORT(_getpidinfo)\
ENTRY(getpidinfo)\
	jmp	_C_LABEL(_getpidinfo)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf2 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf3 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 FICHIER : \cf2 ~/src/lib/libc/syscall/Makefile.inc\cf0 \
Ajouter \cf3 getpidinfo.S \\\cf0 \
\
\
(dans le dossier o\'f9 se trouve minix)\
\cf7 make run\
./update_minix\cf0  -> inclure les modifs\cf5 \
\cf7 cd /usr/src/tools\
make hdboot libraries\cf0  -> compiler\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Il faut maintenant tester le r\'e9sutlat.\
\
\cf7 cd\
cd test/getpidinfo\
make test\
make run\cf0 \
\
Le fichier de test est le suivant (\cf2 test.c\cf0 ) :\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 \CocoaLigature0 #include <lib.h>\
#include <sys/types.h>                                                          \
#include <unistd.h>                                                             \
#include <stdio.h>                                                              \
                                                                                \
int main (void)                                                                 \
\{                                                                               \
  struct pid_s pids = \{42, 42\};\
  int i;\
  message m;\
        \
  printf("-- Actual values --\\n");\
  printf("getpid() : %d\\n", getpid());\
  printf("getppid() : %d\\n", getppid());\
  \
  printf("\\n-- Raw system call --\\n");\
  printf("Syscall %d, %d, %d\\n", _syscall(PM_PROC_NR, 32, &m), m.m2_i1, m.m2_i2);                         \
                                     \
  printf("\\n-- Our values --\\n");                                           \
  i = getpidinfo(&pids);                                                        \
  printf("getpidinfo() result : %d\\n", i);        \
  printf("getpidinfo() pid : %d\\n", pids.me);\
  printf("getpidinfo() ppid : %d\\n", pids.parent);\
\
  if (getpid() == pids.me && getppid() == pids.parent) \{\
	printf("\\nGood job!\\n");\
	return 0;\
  \} else \{\
	printf("\\nValues do not match!\\n");\
	return -1;\
  \}                                                     \
\}\cf5 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf5 \
OK getpidinfo\
J'ai chang\'e9 le > en un >= sur les ordis des salles. L'assistant a l'air de dire que c'est bien de mettre >= que ==.\
\
KO syscall\
L'assistant trouve ca bizarre que quand on fait le syscall ca n'aille pas mais que quand on fait la m\'eame chose dans\
l'appel syst\'e8me ca marche. Je pense qu'on peut se permettre de pas trop se tracasser sur ca, le but c'est que getpidinfo\
marche. \
\
Bref je pense qu'on est bons l\'e0 :) Le dernier truc \'e0 faire me semble de virer les printf!\
}