{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red63\green105\blue30;\red221\green32\blue103;\red98\green147\blue254;
\red168\green24\blue75;}
{\info
{\author Lena Peschke}}\paperw11905\paperh16837\margl1440\margr1440\vieww16880\viewh9440\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\qc

\f0\fs24 \cf0 Impl\'e9mentation de l\'92appel syst\'e8me getpidinfo\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
ssh identifiant@studssh.info.ucl.ac.be (peschke)\
[mot de passe] (beihau6Quo8v)\
ssh volcan01\
[mot de passe]\
[se placer dans le r\'e9pertoire de minix]\
\
FICHIER : \cf2 ~/src/include/minix/callnr.h\cf0 \
Rep\'e9rer un num\'e9ro non utilis\'e9 (32)\
Ajouter \cf3 #define GETPIDINFO	  32\cf0 \
\
\
FICHIER : \cf2 ~/src/servers/pm/table.c\cf0 \
Ajouter \cf3 do_getpidinfo,	/* 32 = getpidinfo */\cf0 \
\
\
FICHIER : \cf2 ~/src/servers/pm/proto.h\cf0 \
Ajouter \cf3 _PROTOTYPE( int do_getpidinfo,(void)			);\cf0 \
dans la section /* misc.c */\
\
\
FICHIER : \cf2 ~/src/server/pm/misc.c\cf0 \
Ajouter le code ci-dessous; attention \'e0 ne pas utiliser de commentaire //, donc seulement  des /* text */. On peut s\'92inspirer de la fonction do_getepinfo dans le m\'eame fichier, qui ressemble sur plusieurs points (elle utilise aussi mp, elle fonctionne aussi par messages et met \'e0 jour errno), et de ce qui se trouve dans getset.c.\
\
1er essai\
/*===========================================================================*\
 *				do_getpidinfo						                                                          *\
 *===========================================================================*/\
PUBLIC int do_getpidinfo(void)\
\{\
  /* mproc est aussi variable ext!! (mproc) */\
  pid_t me, parent;\
\
  /* Get pid and ppid */\
  me = mp->mp_pid;\
  parent = mproc[mp->mp_parent].mp_pid;\
\
  /* Message */\
  if (mp->mp_flags & IN_USE) \{\
	mp->mp_reply.reply_res2 = me;\
	mp->mp_reply.reply_res3 = parent;\
  	return(OK);\
  \}\
\
  /* Inactive process */\
  return(ESRCH);\
\}\
\
2e essai\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \CocoaLigature0 /*===========================================================================*\
 *				do_getpidinfo				     *\
 *===========================================================================*/\
PUBLIC int do_getpidinfo()\
\{\
  /* mproc is an extern variable */\
\
  pid_t me, parent;\
\
  /* Get pid and ppid */\
  me = mproc[who_p].mp_pid;\
  parent = mproc[mp->mp_parent].mp_pid;\
\
  /* Message */\
  if (mp->mp_flags & IN_USE) \{\
	mp->mp_reply.reply_res2 = me;\
	mp->mp_reply.reply_res3 = parent;\
  	return(OK);\
  \}\
\
  /* Inactive process */\
  return(ESRCH);\
\}\
\
3e essai\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 /*===========================================================================*\
 *				do_getpidinfo				     *\
 *===========================================================================*/\
PUBLIC int do_getpidinfo()\
\{\
  /* mproc is an extern variable */\
\
  /* Message */\
  if (mp->mp_flags & IN_USE) \{\
	printf("entered system call\\n");\
\
	mp->mp_reply.reply_res2 = mproc[who_p].mp_pid;\
	mp->mp_reply.reply_res3 = mproc[mp->mp_parent].mp_pid;\
\
	printf("successful system call\\n");\
  	return(OK);\
  \}\
\
  /* Inactive process */\
  return(ESRCH);\
\}\CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
A cette \'e9tape, il faut comprendre plusieurs choses. Le r\'e9pertoire pm/ contient full fichiers .h. Voici un aper\'e7u:\
\
glo.h : contient toutes les variables globales. C\'92est ici qu\'92est d\'e9clar\'e9 struct mproc *mp qui est la *table* du processus courant contenant toutes ses infos. Cette structure est d\'e9finie ailleurs, mais retenons que comme elle est d\'e9clar\'e9e externe ici, on ne doit plus la d\'e9clarer et la chercher pour notre appel.\
\
mproc.h : c\'92est ici que struct mproc *mp est d\'e9finie. Vaut la peine d\'92\'eatre lu. On se rend compte que c\'92est une table de structure qui contient tous les processus. mp (voir ci-dessus) pointe sur l\'92entr\'e9e du processus courant. A l\'92int\'e9rieur de la structure, on retrouve les champs pid_t mp_pid et int mp_parent qui donne respectivement le pid du processus et l\'92index dans mproc[NR_PROCS] de son parent. Autre chose d\'92important : message mp_reply. Pour comprendre ce champ, il faut savoir que tout appel syst\'e8me est appel\'e9 comme ceci : _syscall(PM_PROC_NR, PROC_NAME, &m); avec comme arguments la table qui donne les num\'e9ros au appels syst\'e8mes (je crois), le nom de l\'92appel syst\'e8me et le pointeur d\'92un message. mp_reply (le message) contient lui-m\'eame plusieurs champs.\
Endroit de mp et de mproc[]!!!!!\
\
param.h : contient des d\'e9finitions des champs d\'92un message. On s\'92int\'e9resse \'e0 reply_res2 et reply_res3, dans lesquels on peut placer des int pour un retour de donn\'e9es multiples (chez nous donc pid et ppid).\
\
pm.h : master-fichier-header. Tous les fichiers .c du dossier l\'92includent.\
\
\
FICHIER : \cf2 ~/src/include/minix/type.h\cf0  : C\'92est ici qu\'92on ajoute la d\'e9finition de la nouvelle structure.\
\cf3 struct pid_s \{\
	pid_t me;\
	pid_t parent;\
\};\cf0 \
\
\
(dans le dossier o\'f9 se trouve minix)\
make run\
cd /usr/src/servers/pm/\
make\
(resortir)\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
A ce stade, l\'92appel syst\'e8me existe et il faut le rendre accessible aux utilisateurs de mani\'e8re plus ais\'e9e que par _syscall(\'85).\
\
\
FICHIER : \cf2 ~/src/lib/libc/other\cf0 \
Il y a plusieurs dossiers de librairie, mais celui-ci me paraissait le plus appropri\'e9 pour notre appel syst\'e8me. C\'92est ici qu\'92est utilis\'e9 getepinfo, pas en tant que tel mais pour plusieurs sous-fonctions (_getngid.c, _getnuid.c,\'85).\
Ajouter un nouveau fichier _\cf2 getpidinfo.c\cf0  :\
\
1er essai : \
\
#include <lib.h>\
#include <unistd.h>\
\
PUBLIC int getpidinfo(struct pid_s *pids)\
\{\
  message m;\
\
  if (_syscall(PM_PROC_NR, GETPIDINFO, &m) < 0) return ( (pid_t) -1);\
  pids->me = (pid_t) m.m2_i1;\
  pids->parent = (pid_t) m.m2_i2;\
\
  return OK;\
\}\
\
2\'e8me essai : \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 \CocoaLigature0 #include <lib.h>\
#include <unistd.h>\
\
PUBLIC int getpidinfo(struct pid_s *pids)\
\{\
  message m;\
  int result;\
\
  result = _syscall(PM_PROC_NR, GETPIDINFO, &m);\
  if (result > 0) \{\
	pids->me = (pid_t) m.m2_i1;\
	pids->parent = (pid_t) m.m2_i2;\
  \}\
\
  return result;\
\} \
\
3\'e8me essai : \cf3 \
\
#include <lib.h>\
#define getpidinfo _getpidinfo\
#include <unistd.h>\
\
PUBLIC int getpidinfo(struct pid_s *pids)\
\{  \
  message m;\
  int result;\
\
  printf("entered user call\\n");\
\
  result = _syscall(PM_PROC_NR, GETPIDINFO, &m);\
  if (result \cf4 >=\cf3  0) \{\
	pids->me = (pid_t) m.m2_i1;\
	pids->parent = (pid_t) m.m2_i2;\
\
	printf("m.m2_i1 %d\\n", m.m2_i1);\
	printf("m.m2_i2 %d\\n", m.m2_i2);\
\
	printf("pids->me %d\\n", pids->me,);\
	printf("pids->parent %d\\n", pids->parent);\
\
  \}\
\
  return result;\
\} \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf5 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
FICHIER : \cf2 ~/src/lib/libc/other/Makefile.inc\cf0 \
Ajouter \cf3 _getpidinfo.c \\\cf0  dans la liste\
\
\
FICHIER : \cf2 ~/src/include/unistd.h\
\cf0 Ajouter\cf3  _PROTOTYPE( int getpidinfo, (struct pid_s *pids)		);\
\
\
\cf0 FICHIER : \cf2 ~/src/lib/libc/syscall\cf0 \
Ajouter un fichier \cf2 getpidinfo.S\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf3 \CocoaLigature0 #include <machine/asm.h>\
\
IMPORT(_getpidinfo)\
ENTRY(getpidinfo)\
	jmp	_C_LABEL(_getpidinfo)\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf2 \CocoaLigature1 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf3 \
\cf0 FICHIER : \cf2 ~/src/lib/libc/Makefile.inc\cf0 \
Ajouter \cf3 getpidinfo.S \\\cf0 \
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
(dans le dossier o\'f9 se trouve minix)\
make run\
./update_minix -> inclure les modifs\
\cf4 nb : si ./update_minix fait chier virer ce qu'il y a dans know_hosts ;)\
\cf0 cd /usr/src/tools\
make hdboot libraries -> compiler\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\cf4 LE TEST\
\
OK getpidinfo\
J'ai chang\'e9 le > en un >= sur les ordis des salles. L'assistant a l'air de dire que c'est bien de mettre >= que ==.\
\
KO syscall\
L'assistant trouve ca bizarre que quand on fait le syscall ca n'aille pas mais que quand on fait la m\'eame chose dans\
l'appel syst\'e8me ca marche. Je pense qu'on peut se permettre de pas trop se tracasser sur ca, le but c'est que getpidinfo\
marche. \cf0 \
}